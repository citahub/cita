# Bootstrap

通过本文所述方法和项目中的脚本，我们可以快速的搭建`CITA`环境，进行智能合约的开发测试。

## 部署CITA

为了简化`CITA`的部署，帮助用户快速搭建`CITA`运行环境，我们推荐使用`docker`部署 `CITA`。

具体步骤请参见[快速入门](./getting_started)

在发布件目录启动所有的`CITA`节点后，直接运行`./env.sh`获取一个docker环境的shell。

后续命令都在这个shell中执行。

## 部署智能合约

CITA完全兼容以太坊的智能合约，`solidity`是基于以太坊的智能合约最为推荐的编程语言，因此我们也采用`solidity`语言来编写和测试智能合约。

### 编译

智能合约的源码文件，需要先使用solidity编译器`solc`编译成字节码。

我们提供的docker环境中已经包含了`solc`。在shell中执行`solc --version`查看版本信息：

```shell
# solc --version
solc, the solidity compiler commandline interface
Version: 0.4.19+commit.c4cbbb05.Linux.g++
```

`CITA`发布件中包含了一些智能合约示例，存放在 `scripts/contracts/tests/contracts`中。

以`test_example.sol`为例。这是一个很简单的合约文件，只提供了简单的`get`和`set`方法。我们可以先调用`set`方法存储一个任意数值，然后再调用`get`方法验证存储是否生效，以此来检验合约部署和运行是否正常。

的执行：

```shell
# cd scripts/contracts/tests/contracts
# solc test_example.sol --bin
======= test_example.sol:SimpleStorage =======
Binary: 
6060604052341561000f57600080fd5b60d38061001d6000396000f3006060604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c14606e575b600080fd5b3415605857600080fd5b606c60048080359060200190919050506094565b005b3415607857600080fd5b607e609e565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a7230582020642d4bfc8bb29cfd3390d1aafea86ec7219a70889a640325d7fabb0b0534960029
```

如果文件没有错误，返回结果中将会包括`test_example.sol`的字节码。

### 部署合约

得到合约字节码后，就可以将其部署到`CITA`链上了，部署的方法已经用`python`脚本封装，只需要传入私钥和字节码即可。

目前支持的`python`版本是2.7，`python`脚本存放的位置为`scripts/txtool/txtool`，具体安装和使用方法可以参考目录下的`README.md`文件。

划重点， txtool在使用上有限制：不能在别的目录通过相对路径调用，一定要cd到scripts/txtool/txtool目录下。

docker环境已经包含了该工具的依赖，可以直接运行命令部署合约：

```shell
cd scripts/txtool/txtool
python make_tx.py --privkey "352416e1c910e413768c51390dfd791b414212b7b4fe6b1a18f58007fa894214" --code     "606060405234156100105760006000fd5b610015565b60e0806100236000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604b5780636d4ce63c14606c576045565b60006000fd5b341560565760006000fd5b606a60048080359060200190919050506093565b005b341560775760006000fd5b607d60a3565b6040518082815260200191505060405180910390f35b8060006000508190909055505b50565b6000600060005054905060b1565b905600a165627a7a72305820942223976c6dd48a3aa1d4749f45ad270915cfacd9c0bf3583c018d4c86f9da20029"
```

参数解释：`code`为第一步中获得的字节码, `privkey`可随意设置。

### 发送交易

执行：`python send_tx.py`

结果如下:

```shell
{
    "jsonrpc":"2.0",
    "id":1,
    "result":
    {
        "hash":"0xa02fa9a94de11d288449ccbe8c5de5916116433b167eaec37455e402e1ab53d3",
        "status":"Ok"
    }
}
```

`status`为`OK`，表示合约已经发送到`CITA`链上。

注意：上一步生成的交易具有时效性，如果执行结果为`InvalidUntilBlock`，请重新执行上一步`生成交易`，并尽快执行`发送交易`。

### 获得回执

执行：`python get_receipt.py`

结果如下:

```shell
{
    "contractAddress": "0x73552bc4e960a1d53013b40074569ea05b950b4d",          // 合约地址
    "cumulativeGasUsed": "0xafc8",
    "logs": [],
    "blockHash": "0x14a311d9f026ab592e6d156f2ac6244b153816eeec18717802ee9e675f0bfbbd",
    "transactionHash": "0x61854d356645ab5aacd24616e59d76ac639c5a5c2ec79292f8e8fb409b42177b",
    "root": null,
    "errorMessage": null,
    "blockNumber": "0x6",                                                     // 区块高度
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "transactionIndex": "0x0",
    "gasUsed": "0xafc8"
}
```

这里需要重点关注`contractAddress`和`blockNumber`，下文调用合约方法会用到。

### 方法Hash

合约的调用是通过发送交易命令完成，调用具体的方法则是通过方法`hash`值完成

执行：`solc test_example.sol --hash`

结果如下:

```shell
======= example.sol:SimpleStorage =======
Function signatures:
6d4ce63c: get()                         // get方法hash值
60fe47b1: set(uint256)                  // set方法hash值
```

这里的`get`和`set`方法`hash`值是`CITA`链上的唯一标示值，下文调用合约方法会用到。

### 调用合约方法

假定我们调用`set`方法，参数为1，也就是说将数值1存储到区块链内存中。

```shell
python make_tx.py --privkey "352416e1c910e413768c51390dfd791b414212b7b4fe6b1a18f58007fa894214" --to "73552bc4e960a1d53013b40074569ea05b950b4d" --code "60fe47b10000000000000000000000000000000000000000000000000000000000000001"
```

`privkey`是你的私钥，`to`参数是合约的目标地址，`code`参数是`set`方法和参数`hash`值的拼接，`set`方法的`hash`值为60fe47b1，将参数1转换为uint256，转换成16进制就是64位。

### 发送交易命令

执行：`python send_tx.py`

```shell
{
    "jsonrpc":"2.0",
    "id":1,
    "result":
    {
        "hash":"0xf29935d0221cd8ef2cb6a265e0a963ca172aca4f6e43728d2ccae3127631d590",
        "status":"Ok"
    }
}
```

注意：上一步生成的交易具有时效性，如果执行结果为`InvalidUntilBlock`，请重新执行上一步`生成交易`，并尽快执行`发送交易`。

### 获得调用回执

执行：`python get_receipt.py`

结果如下：

```shell
{
    "contractAddress": null,
    "cumulativeGasUsed": "0x4f2d",
    "logs": [],
    "blockHash": "0x2a10ae38be9e1816487dbfb34bce7f440d60035e8978146caef5d14608bb222c",
    "transactionHash": "0xf29935d0221cd8ef2cb6a265e0a963ca172aca4f6e43728d2ccae3127631d590",
    "root": null,
    "errorMessage": null,
    "blockNumber": "0x15",                    // 区块的高度
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "transactionIndex": "0x0",
    "gasUsed": "0x4f2d"
}
```

### 验证效果

调用合约中的`get`方法，验证之前`set`方法的执行效果

```shell
curl -X POST --data '{"jsonrpc":"2.0","method":"eth_call", "params":[{"to":"0x73552bc4e960a1d53013b40074569ea05b950b4d", "data":"0x6d4ce63c"}, "latest"],"id":2}' 127.0.0.1:1337
```

其中`to`参数为合约目标地址，`data`为`get`方法的`hash`值

结果如下：

```shell
{
    "jsonrpc":"2.0",
    "id":2,
    "result":"0x0000000000000000000000000000000000000000000000000000000000000001"
}
```

如果返回值中`result`值为1，表明合约调用生效
