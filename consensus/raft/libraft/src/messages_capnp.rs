// Generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: messages.capnp


pub mod connection_preamble {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_id(self) -> ::messages_capnp::connection_preamble::id::Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.reader)
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_id(self) -> ::messages_capnp::connection_preamble::id::Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(self.builder)
        }
        #[inline]
        pub fn init_id(self) -> ::messages_capnp::connection_preamble::id::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 0);
            self.builder.get_pointer_field(0).clear();
            ::capnp::traits::FromStructBuilder::new(self.builder)
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {
        pub fn get_id(&self) -> ::messages_capnp::connection_preamble::id::Pipeline {
            FromTypelessPipeline::new(self._typeless.noop())
        }
    }
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xc76ac7e732493b96;
    }

    pub mod id {
#![allow(unused_imports)]

        pub use self::Which::{Server, Client};
        use capnp::{text, data, Result};
        use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
        use capnp::capability::{FromClientHook, FromTypelessPipeline};
        use capnp::private::layout;
        use capnp::traits::{FromStructBuilder, FromStructReader};

        pub struct Owned;
        impl<'a> ::capnp::traits::Owned<'a> for Owned {
            type Reader = Reader<'a>;
            type Builder = Builder<'a>;
        }
        impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
            type Reader = Reader<'a>;
            type Builder = Builder<'a>;
        }
        impl ::capnp::traits::Pipelined for Owned {
            type Pipeline = Pipeline;
        }

        #[derive(Clone, Copy)]
        pub struct Reader<'a> {
            reader: layout::StructReader<'a>,
        }

        impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
            #[inline]
            fn type_id() -> u64 {
                _private::TYPE_ID
            }
        }
        impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
            fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
                Reader { reader: reader }
            }
        }

        impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
            fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
                ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
            }
        }

        impl<'a> Reader<'a> {
            pub fn borrow<'b>(&'b self) -> Reader<'b> {
                Reader { ..*self }
            }

            pub fn total_size(&self) -> Result<::capnp::MessageSize> {
                self.reader.total_size()
            }
            pub fn has_server(&self) -> bool {
                if self.reader.get_data_field::<u16>(0) != 0 {
                    return false;
                }
                !self.reader.get_pointer_field(0).is_null()
            }
            pub fn has_client(&self) -> bool {
                if self.reader.get_data_field::<u16>(0) != 1 {
                    return false;
                }
                !self.reader.get_pointer_field(0).is_null()
            }
            #[inline]
            pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
                match self.reader.get_data_field::<u16>(0) {
                    0 => {
                        return ::std::result::Result::Ok(Server(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                    }
                    1 => {
                        return ::std::result::Result::Ok(Client(self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)));
                    }
                    x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
                }
            }
        }

        pub struct Builder<'a> {
            builder: ::capnp::private::layout::StructBuilder<'a>,
        }
        impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
            #[inline]
            fn struct_size() -> layout::StructSize {
                _private::STRUCT_SIZE
            }
        }
        impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
            #[inline]
            fn type_id() -> u64 {
                _private::TYPE_ID
            }
        }
        impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
            fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
                Builder { builder: builder }
            }
        }

        impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
            fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
                ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
            }
            fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
                ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
            }
        }

        impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
            fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
                pointer.set_struct(&value.reader)
            }
        }

        impl<'a> Builder<'a> {
            pub fn as_reader(self) -> Reader<'a> {
                ::capnp::traits::FromStructReader::new(self.builder.as_reader())
            }
            pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
                Builder { ..*self }
            }
            pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
                ::capnp::traits::FromStructReader::new(self.builder.as_reader())
            }

            pub fn total_size(&self) -> Result<::capnp::MessageSize> {
                self.builder.as_reader().total_size()
            }
            #[inline]
            pub fn set_server<'b>(&mut self, value: ::messages_capnp::peer::Reader<'b>) -> Result<()> {
                self.builder.set_data_field::<u16>(0, 0);
                ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
            }
            #[inline]
            pub fn init_server(self) -> ::messages_capnp::peer::Builder<'a> {
                self.builder.set_data_field::<u16>(0, 0);
                ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
            }
            pub fn has_server(&self) -> bool {
                if self.builder.get_data_field::<u16>(0) != 0 {
                    return false;
                }
                !self.builder.get_pointer_field(0).is_null()
            }
            #[inline]
            pub fn set_client(&mut self, value: data::Reader) {
                self.builder.set_data_field::<u16>(0, 1);
                self.builder.get_pointer_field(0).set_data(value);
            }
            #[inline]
            pub fn init_client(self, size: u32) -> data::Builder<'a> {
                self.builder.set_data_field::<u16>(0, 1);
                self.builder.get_pointer_field(0).init_data(size)
            }
            pub fn has_client(&self) -> bool {
                if self.builder.get_data_field::<u16>(0) != 1 {
                    return false;
                }
                !self.builder.get_pointer_field(0).is_null()
            }
            #[inline]
            pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
                match self.builder.get_data_field::<u16>(0) {
                    0 => {
                        return ::std::result::Result::Ok(Server(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                    }
                    1 => {
                        return ::std::result::Result::Ok(Client(self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)));
                    }
                    x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
                }
            }
        }

        pub struct Pipeline {
            _typeless: ::capnp::any_pointer::Pipeline,
        }
        impl FromTypelessPipeline for Pipeline {
            fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
                Pipeline { _typeless: typeless }
            }
        }
        impl Pipeline {}
        mod _private {
            use capnp::private::layout;
            pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
            pub const TYPE_ID: u64 = 0x9c9ae9e477994c1f;
        }
        pub enum Which<A0, A1> {
            Server(A0),
            Client(A1),
        }
        pub type WhichReader<'a> = Which<Result<::messages_capnp::peer::Reader<'a>>, Result<data::Reader<'a>>>;
        pub type WhichBuilder<'a> = Which<Result<::messages_capnp::peer::Builder<'a>>, Result<data::Builder<'a>>>;
    }
}

pub mod peer {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_id(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn get_addr(self) -> Result<text::Reader<'a>> {
            self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)
        }
        pub fn has_addr(&self) -> bool {
            !self.reader.get_pointer_field(0).is_null()
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_id(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_id(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn get_addr(self) -> Result<text::Builder<'a>> {
            self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)
        }
        #[inline]
        pub fn set_addr(&mut self, value: text::Reader) {
            self.builder.get_pointer_field(0).set_text(value);
        }
        #[inline]
        pub fn init_addr(self, size: u32) -> text::Builder<'a> {
            self.builder.get_pointer_field(0).init_text(size)
        }
        pub fn has_addr(&self) -> bool {
            !self.builder.get_pointer_field(0).is_null()
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xaaaaa6360bd497af;
    }
}

pub mod entry {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn get_data(self) -> Result<data::Reader<'a>> {
            self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
        }
        pub fn has_data(&self) -> bool {
            !self.reader.get_pointer_field(0).is_null()
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn get_data(self) -> Result<data::Builder<'a>> {
            self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
        }
        #[inline]
        pub fn set_data(&mut self, value: data::Reader) {
            self.builder.get_pointer_field(0).set_data(value);
        }
        #[inline]
        pub fn init_data(self, size: u32) -> data::Builder<'a> {
            self.builder.get_pointer_field(0).init_data(size)
        }
        pub fn has_data(&self) -> bool {
            !self.builder.get_pointer_field(0).is_null()
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xedd5d5b66c11a893;
    }
}

pub mod message {
#![allow(unused_imports)]

    pub use self::Which::{AppendEntriesRequest, AppendEntriesResponse, RequestVoteResponse, RequestVoteRequest};
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        pub fn has_append_entries_request(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_append_entries_response(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 1 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_request_vote_response(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_request_vote_request(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 3 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
            match self.reader.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(AppendEntriesRequest(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                1 => {
                    return ::std::result::Result::Ok(AppendEntriesResponse(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                2 => {
                    return ::std::result::Result::Ok(RequestVoteResponse(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                3 => {
                    return ::std::result::Result::Ok(RequestVoteRequest(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn set_append_entries_request<'b>(&mut self, value: ::messages_capnp::append_entries_request::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 0);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_append_entries_request(self) -> ::messages_capnp::append_entries_request::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 0);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_append_entries_request(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_append_entries_response<'b>(&mut self, value: ::messages_capnp::append_entries_response::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 1);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_append_entries_response(self) -> ::messages_capnp::append_entries_response::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 1);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_append_entries_response(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 1 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_request_vote_response<'b>(&mut self, value: ::messages_capnp::request_vote_response::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 2);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_request_vote_response(self) -> ::messages_capnp::request_vote_response::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 2);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_request_vote_response(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_request_vote_request<'b>(&mut self, value: ::messages_capnp::request_vote_request::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 3);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_request_vote_request(self) -> ::messages_capnp::request_vote_request::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 3);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_request_vote_request(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 3 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
            match self.builder.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(AppendEntriesRequest(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                1 => {
                    return ::std::result::Result::Ok(AppendEntriesResponse(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                2 => {
                    return ::std::result::Result::Ok(RequestVoteResponse(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                3 => {
                    return ::std::result::Result::Ok(RequestVoteRequest(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xd71057750227a223;
    }
    pub enum Which<A0, A1, A2, A3> {
        AppendEntriesRequest(A0),
        AppendEntriesResponse(A1),
        RequestVoteResponse(A2),
        RequestVoteRequest(A3),
    }
    pub type WhichReader<'a> = Which<Result<::messages_capnp::append_entries_request::Reader<'a>>, Result<::messages_capnp::append_entries_response::Reader<'a>>, Result<::messages_capnp::request_vote_response::Reader<'a>>, Result<::messages_capnp::request_vote_request::Reader<'a>>>;
    pub type WhichBuilder<'a> = Which<Result<::messages_capnp::append_entries_request::Builder<'a>>, Result<::messages_capnp::append_entries_response::Builder<'a>>, Result<::messages_capnp::request_vote_response::Builder<'a>>, Result<::messages_capnp::request_vote_request::Builder<'a>>>;
}

pub mod append_entries_request {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn get_prev_log_index(self) -> u64 {
            self.reader.get_data_field::<u64>(1)
        }
        #[inline]
        pub fn get_prev_log_term(self) -> u64 {
            self.reader.get_data_field::<u64>(2)
        }
        #[inline]
        pub fn get_entries(self) -> Result<struct_list::Reader<'a, ::messages_capnp::entry::Owned>> {
            ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))
        }
        pub fn has_entries(&self) -> bool {
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn get_leader_commit(self) -> u64 {
            self.reader.get_data_field::<u64>(3)
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn get_prev_log_index(self) -> u64 {
            self.builder.get_data_field::<u64>(1)
        }
        #[inline]
        pub fn set_prev_log_index(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(1, value);
        }
        #[inline]
        pub fn get_prev_log_term(self) -> u64 {
            self.builder.get_data_field::<u64>(2)
        }
        #[inline]
        pub fn set_prev_log_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(2, value);
        }
        #[inline]
        pub fn get_entries(self) -> Result<struct_list::Builder<'a, ::messages_capnp::entry::Owned>> {
            ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))
        }
        #[inline]
        pub fn set_entries(&mut self, value: struct_list::Reader<'a, ::messages_capnp::entry::Owned>) -> Result<()> {
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_entries(self, size: u32) -> struct_list::Builder<'a, ::messages_capnp::entry::Owned> {
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
        }
        pub fn has_entries(&self) -> bool {
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn get_leader_commit(self) -> u64 {
            self.builder.get_data_field::<u64>(3)
        }
        #[inline]
        pub fn set_leader_commit(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(3, value);
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 4, pointers: 1 };
        pub const TYPE_ID: u64 = 0xd1523c095dbc47bb;
    }
}

pub mod append_entries_response {
#![allow(unused_imports)]

    pub use self::Which::{Success, StaleTerm, InconsistentPrevEntry, InternalError};
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        pub fn has_internal_error(&self) -> bool {
            if self.reader.get_data_field::<u16>(8) != 3 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
            match self.reader.get_data_field::<u16>(8) {
                0 => {
                    return ::std::result::Result::Ok(Success(self.reader.get_data_field::<u64>(1)));
                }
                1 => {
                    return ::std::result::Result::Ok(StaleTerm(()));
                }
                2 => {
                    return ::std::result::Result::Ok(InconsistentPrevEntry(self.reader.get_data_field::<u64>(1)));
                }
                3 => {
                    return ::std::result::Result::Ok(InternalError(self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn set_success(&mut self, value: u64) {
            self.builder.set_data_field::<u16>(8, 0);
            self.builder.set_data_field::<u64>(1, value);
        }
        #[inline]
        pub fn set_stale_term(&mut self, _value: ()) {
            self.builder.set_data_field::<u16>(8, 1);
        }
        #[inline]
        pub fn set_inconsistent_prev_entry(&mut self, value: u64) {
            self.builder.set_data_field::<u16>(8, 2);
            self.builder.set_data_field::<u64>(1, value);
        }
        #[inline]
        pub fn set_internal_error(&mut self, value: text::Reader) {
            self.builder.set_data_field::<u16>(8, 3);
            self.builder.get_pointer_field(0).set_text(value);
        }
        #[inline]
        pub fn init_internal_error(self, size: u32) -> text::Builder<'a> {
            self.builder.set_data_field::<u16>(8, 3);
            self.builder.get_pointer_field(0).init_text(size)
        }
        pub fn has_internal_error(&self) -> bool {
            if self.builder.get_data_field::<u16>(8) != 3 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
            match self.builder.get_data_field::<u16>(8) {
                0 => {
                    return ::std::result::Result::Ok(Success(self.builder.get_data_field::<u64>(1)));
                }
                1 => {
                    return ::std::result::Result::Ok(StaleTerm(()));
                }
                2 => {
                    return ::std::result::Result::Ok(InconsistentPrevEntry(self.builder.get_data_field::<u64>(1)));
                }
                3 => {
                    return ::std::result::Result::Ok(InternalError(self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 3, pointers: 1 };
        pub const TYPE_ID: u64 = 0xe989abe9546f27b1;
    }
    pub enum Which<A0> {
        Success(u64),
        StaleTerm(()),
        InconsistentPrevEntry(u64),
        InternalError(A0),
    }
    pub type WhichReader<'a> = Which<Result<text::Reader<'a>>>;
    pub type WhichBuilder<'a> = Which<Result<text::Builder<'a>>>;
}

pub mod request_vote_request {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn get_last_log_index(self) -> u64 {
            self.reader.get_data_field::<u64>(1)
        }
        #[inline]
        pub fn get_last_log_term(self) -> u64 {
            self.reader.get_data_field::<u64>(2)
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn get_last_log_index(self) -> u64 {
            self.builder.get_data_field::<u64>(1)
        }
        #[inline]
        pub fn set_last_log_index(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(1, value);
        }
        #[inline]
        pub fn get_last_log_term(self) -> u64 {
            self.builder.get_data_field::<u64>(2)
        }
        #[inline]
        pub fn set_last_log_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(2, value);
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 3, pointers: 0 };
        pub const TYPE_ID: u64 = 0x8b9c37e9ceb1b871;
    }
}

pub mod request_vote_response {
#![allow(unused_imports)]

    pub use self::Which::{Granted, StaleTerm, AlreadyVoted, InconsistentLog, InternalError};
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        pub fn has_internal_error(&self) -> bool {
            if self.reader.get_data_field::<u16>(4) != 4 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
            match self.reader.get_data_field::<u16>(4) {
                0 => {
                    return ::std::result::Result::Ok(Granted(()));
                }
                1 => {
                    return ::std::result::Result::Ok(StaleTerm(()));
                }
                2 => {
                    return ::std::result::Result::Ok(AlreadyVoted(()));
                }
                3 => {
                    return ::std::result::Result::Ok(InconsistentLog(()));
                }
                4 => {
                    return ::std::result::Result::Ok(InternalError(self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn set_granted(&mut self, _value: ()) {
            self.builder.set_data_field::<u16>(4, 0);
        }
        #[inline]
        pub fn set_stale_term(&mut self, _value: ()) {
            self.builder.set_data_field::<u16>(4, 1);
        }
        #[inline]
        pub fn set_already_voted(&mut self, _value: ()) {
            self.builder.set_data_field::<u16>(4, 2);
        }
        #[inline]
        pub fn set_inconsistent_log(&mut self, _value: ()) {
            self.builder.set_data_field::<u16>(4, 3);
        }
        #[inline]
        pub fn set_internal_error(&mut self, value: text::Reader) {
            self.builder.set_data_field::<u16>(4, 4);
            self.builder.get_pointer_field(0).set_text(value);
        }
        #[inline]
        pub fn init_internal_error(self, size: u32) -> text::Builder<'a> {
            self.builder.set_data_field::<u16>(4, 4);
            self.builder.get_pointer_field(0).init_text(size)
        }
        pub fn has_internal_error(&self) -> bool {
            if self.builder.get_data_field::<u16>(4) != 4 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
            match self.builder.get_data_field::<u16>(4) {
                0 => {
                    return ::std::result::Result::Ok(Granted(()));
                }
                1 => {
                    return ::std::result::Result::Ok(StaleTerm(()));
                }
                2 => {
                    return ::std::result::Result::Ok(AlreadyVoted(()));
                }
                3 => {
                    return ::std::result::Result::Ok(InconsistentLog(()));
                }
                4 => {
                    return ::std::result::Result::Ok(InternalError(self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 2, pointers: 1 };
        pub const TYPE_ID: u64 = 0xbfa9b0b184d3583e;
    }
    pub enum Which<A0> {
        Granted(()),
        StaleTerm(()),
        AlreadyVoted(()),
        InconsistentLog(()),
        InternalError(A0),
    }
    pub type WhichReader<'a> = Which<Result<text::Reader<'a>>>;
    pub type WhichBuilder<'a> = Which<Result<text::Builder<'a>>>;
}

pub mod client_request {
#![allow(unused_imports)]

    pub use self::Which::{Ping, Proposal, Query};
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        pub fn has_ping(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_proposal(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 1 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_query(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
            match self.reader.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(Ping(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                1 => {
                    return ::std::result::Result::Ok(Proposal(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                2 => {
                    return ::std::result::Result::Ok(Query(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn set_ping<'b>(&mut self, value: ::messages_capnp::ping_request::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 0);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_ping(self) -> ::messages_capnp::ping_request::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 0);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_ping(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_proposal<'b>(&mut self, value: ::messages_capnp::proposal_request::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 1);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_proposal(self) -> ::messages_capnp::proposal_request::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 1);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_proposal(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 1 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_query<'b>(&mut self, value: ::messages_capnp::query_request::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 2);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_query(self) -> ::messages_capnp::query_request::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 2);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_query(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
            match self.builder.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(Ping(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                1 => {
                    return ::std::result::Result::Ok(Proposal(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                2 => {
                    return ::std::result::Result::Ok(Query(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xee9e5848daf8a944;
    }
    pub enum Which<A0, A1, A2> {
        Ping(A0),
        Proposal(A1),
        Query(A2),
    }
    pub type WhichReader<'a> = Which<Result<::messages_capnp::ping_request::Reader<'a>>, Result<::messages_capnp::proposal_request::Reader<'a>>, Result<::messages_capnp::query_request::Reader<'a>>>;
    pub type WhichBuilder<'a> = Which<Result<::messages_capnp::ping_request::Builder<'a>>, Result<::messages_capnp::proposal_request::Builder<'a>>, Result<::messages_capnp::query_request::Builder<'a>>>;
}

pub mod client_response {
#![allow(unused_imports)]

    pub use self::Which::{Ping, Proposal, Query};
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        pub fn has_ping(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_proposal(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 1 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_query(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
            match self.reader.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(Ping(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                1 => {
                    return ::std::result::Result::Ok(Proposal(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                2 => {
                    return ::std::result::Result::Ok(Query(::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0))));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn set_ping<'b>(&mut self, value: ::messages_capnp::ping_response::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 0);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_ping(self) -> ::messages_capnp::ping_response::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 0);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_ping(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_proposal<'b>(&mut self, value: ::messages_capnp::command_response::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 1);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_proposal(self) -> ::messages_capnp::command_response::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 1);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_proposal(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 1 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_query<'b>(&mut self, value: ::messages_capnp::command_response::Reader<'b>) -> Result<()> {
            self.builder.set_data_field::<u16>(0, 2);
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.get_pointer_field(0), value)
        }
        #[inline]
        pub fn init_query(self) -> ::messages_capnp::command_response::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 2);
            ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
        }
        pub fn has_query(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
            match self.builder.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(Ping(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                1 => {
                    return ::std::result::Result::Ok(Proposal(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                2 => {
                    return ::std::result::Result::Ok(Query(::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0))));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xc805da039c12933b;
    }
    pub enum Which<A0, A1, A2> {
        Ping(A0),
        Proposal(A1),
        Query(A2),
    }
    pub type WhichReader<'a> = Which<Result<::messages_capnp::ping_response::Reader<'a>>, Result<::messages_capnp::command_response::Reader<'a>>, Result<::messages_capnp::command_response::Reader<'a>>>;
    pub type WhichBuilder<'a> = Which<Result<::messages_capnp::ping_response::Builder<'a>>, Result<::messages_capnp::command_response::Builder<'a>>, Result<::messages_capnp::command_response::Builder<'a>>>;
}

pub mod ping_request {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 0 };
        pub const TYPE_ID: u64 = 0xa87833b2004c4cba;
    }
}

pub mod ping_response {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.reader.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn get_index(self) -> u64 {
            self.reader.get_data_field::<u64>(1)
        }
        #[inline]
        pub fn get_state(self) -> ::messages_capnp::ping_response::state::Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.reader)
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_term(self) -> u64 {
            self.builder.get_data_field::<u64>(0)
        }
        #[inline]
        pub fn set_term(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(0, value);
        }
        #[inline]
        pub fn get_index(self) -> u64 {
            self.builder.get_data_field::<u64>(1)
        }
        #[inline]
        pub fn set_index(&mut self, value: u64) {
            self.builder.set_data_field::<u64>(1, value);
        }
        #[inline]
        pub fn get_state(self) -> ::messages_capnp::ping_response::state::Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(self.builder)
        }
        #[inline]
        pub fn init_state(self) -> ::messages_capnp::ping_response::state::Builder<'a> {
            self.builder.set_data_field::<u16>(8, 0);
            ::capnp::traits::FromStructBuilder::new(self.builder)
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {
        pub fn get_state(&self) -> ::messages_capnp::ping_response::state::Pipeline {
            FromTypelessPipeline::new(self._typeless.noop())
        }
    }
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 3, pointers: 0 };
        pub const TYPE_ID: u64 = 0xc8e19d589de972c8;
    }

    pub mod state {
#![allow(unused_imports)]

        pub use self::Which::{Leader, Follower, Candidate};
        use capnp::{text, data, Result};
        use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
        use capnp::capability::{FromClientHook, FromTypelessPipeline};
        use capnp::private::layout;
        use capnp::traits::{FromStructBuilder, FromStructReader};

        pub struct Owned;
        impl<'a> ::capnp::traits::Owned<'a> for Owned {
            type Reader = Reader<'a>;
            type Builder = Builder<'a>;
        }
        impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
            type Reader = Reader<'a>;
            type Builder = Builder<'a>;
        }
        impl ::capnp::traits::Pipelined for Owned {
            type Pipeline = Pipeline;
        }

        #[derive(Clone, Copy)]
        pub struct Reader<'a> {
            reader: layout::StructReader<'a>,
        }

        impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
            #[inline]
            fn type_id() -> u64 {
                _private::TYPE_ID
            }
        }
        impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
            fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
                Reader { reader: reader }
            }
        }

        impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
            fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
                ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
            }
        }

        impl<'a> Reader<'a> {
            pub fn borrow<'b>(&'b self) -> Reader<'b> {
                Reader { ..*self }
            }

            pub fn total_size(&self) -> Result<::capnp::MessageSize> {
                self.reader.total_size()
            }
            #[inline]
            pub fn which(self) -> ::std::result::Result<WhichReader, ::capnp::NotInSchema> {
                match self.reader.get_data_field::<u16>(8) {
                    0 => {
                        return ::std::result::Result::Ok(Leader(()));
                    }
                    1 => {
                        return ::std::result::Result::Ok(Follower(()));
                    }
                    2 => {
                        return ::std::result::Result::Ok(Candidate(()));
                    }
                    x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
                }
            }
        }

        pub struct Builder<'a> {
            builder: ::capnp::private::layout::StructBuilder<'a>,
        }
        impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
            #[inline]
            fn struct_size() -> layout::StructSize {
                _private::STRUCT_SIZE
            }
        }
        impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
            #[inline]
            fn type_id() -> u64 {
                _private::TYPE_ID
            }
        }
        impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
            fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
                Builder { builder: builder }
            }
        }

        impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
            fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
                ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
            }
            fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
                ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
            }
        }

        impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
            fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
                pointer.set_struct(&value.reader)
            }
        }

        impl<'a> Builder<'a> {
            pub fn as_reader(self) -> Reader<'a> {
                ::capnp::traits::FromStructReader::new(self.builder.as_reader())
            }
            pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
                Builder { ..*self }
            }
            pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
                ::capnp::traits::FromStructReader::new(self.builder.as_reader())
            }

            pub fn total_size(&self) -> Result<::capnp::MessageSize> {
                self.builder.as_reader().total_size()
            }
            #[inline]
            pub fn set_leader(&mut self, _value: ()) {
                self.builder.set_data_field::<u16>(8, 0);
            }
            #[inline]
            pub fn set_follower(&mut self, _value: ()) {
                self.builder.set_data_field::<u16>(8, 1);
            }
            #[inline]
            pub fn set_candidate(&mut self, _value: ()) {
                self.builder.set_data_field::<u16>(8, 2);
            }
            #[inline]
            pub fn which(self) -> ::std::result::Result<WhichBuilder, ::capnp::NotInSchema> {
                match self.builder.get_data_field::<u16>(8) {
                    0 => {
                        return ::std::result::Result::Ok(Leader(()));
                    }
                    1 => {
                        return ::std::result::Result::Ok(Follower(()));
                    }
                    2 => {
                        return ::std::result::Result::Ok(Candidate(()));
                    }
                    x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
                }
            }
        }

        pub struct Pipeline {
            _typeless: ::capnp::any_pointer::Pipeline,
        }
        impl FromTypelessPipeline for Pipeline {
            fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
                Pipeline { _typeless: typeless }
            }
        }
        impl Pipeline {}
        mod _private {
            use capnp::private::layout;
            pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 3, pointers: 0 };
            pub const TYPE_ID: u64 = 0xfbc3f113f265af41;
        }
        pub enum Which {
            Leader(()),
            Follower(()),
            Candidate(()),
        }
        pub type WhichReader = Which;
        pub type WhichBuilder = Which;
    }
}

pub mod proposal_request {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_entry(self) -> Result<data::Reader<'a>> {
            self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
        }
        pub fn has_entry(&self) -> bool {
            !self.reader.get_pointer_field(0).is_null()
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_entry(self) -> Result<data::Builder<'a>> {
            self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
        }
        #[inline]
        pub fn set_entry(&mut self, value: data::Reader) {
            self.builder.get_pointer_field(0).set_data(value);
        }
        #[inline]
        pub fn init_entry(self, size: u32) -> data::Builder<'a> {
            self.builder.get_pointer_field(0).init_data(size)
        }
        pub fn has_entry(&self) -> bool {
            !self.builder.get_pointer_field(0).is_null()
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 1 };
        pub const TYPE_ID: u64 = 0x8b92eb283fbcbf2c;
    }
}

pub mod query_request {
#![allow(unused_imports)]
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_query(self) -> Result<data::Reader<'a>> {
            self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)
        }
        pub fn has_query(&self) -> bool {
            !self.reader.get_pointer_field(0).is_null()
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_query(self) -> Result<data::Builder<'a>> {
            self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)
        }
        #[inline]
        pub fn set_query(&mut self, value: data::Reader) {
            self.builder.get_pointer_field(0).set_data(value);
        }
        #[inline]
        pub fn init_query(self, size: u32) -> data::Builder<'a> {
            self.builder.get_pointer_field(0).init_data(size)
        }
        pub fn has_query(&self) -> bool {
            !self.builder.get_pointer_field(0).is_null()
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 0, pointers: 1 };
        pub const TYPE_ID: u64 = 0x9b41b660c31b69d4;
    }
}

pub mod command_response {
#![allow(unused_imports)]

    pub use self::Which::{Success, UnknownLeader, NotLeader};
    use capnp::{text, data, Result};
    use capnp::{primitive_list, enum_list, struct_list, text_list, data_list, list_list};
    use capnp::capability::{FromClientHook, FromTypelessPipeline};
    use capnp::private::layout;
    use capnp::traits::{FromStructBuilder, FromStructReader};

    pub struct Owned;
    impl<'a> ::capnp::traits::Owned<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl<'a> ::capnp::traits::OwnedStruct<'a> for Owned {
        type Reader = Reader<'a>;
        type Builder = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructReader<'a> for Reader<'a> {
        fn new(reader: ::capnp::private::layout::StructReader<'a>) -> Reader<'a> {
            Reader { reader: reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>) -> Result<Reader<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructReader::new(try!(reader.get_struct(::std::ptr::null()))))
        }
    }

    impl<'a> Reader<'a> {
        pub fn borrow<'b>(&'b self) -> Reader<'b> {
            Reader { ..*self }
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        pub fn has_success(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        pub fn has_not_leader(&self) -> bool {
            if self.reader.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.reader.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichReader<'a>, ::capnp::NotInSchema> {
            match self.reader.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(Success(self.reader.get_pointer_field(0).get_data(::std::ptr::null(), 0)));
                }
                1 => {
                    return ::std::result::Result::Ok(UnknownLeader(()));
                }
                2 => {
                    return ::std::result::Result::Ok(NotLeader(self.reader.get_pointer_field(0).get_text(::std::ptr::null(), 0)));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        #[inline]
        fn struct_size() -> layout::StructSize {
            _private::STRUCT_SIZE
        }
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        #[inline]
        fn type_id() -> u64 {
            _private::TYPE_ID
        }
    }
    impl<'a> ::capnp::traits::FromStructBuilder<'a> for Builder<'a> {
        fn new(builder: ::capnp::private::layout::StructBuilder<'a>) -> Builder<'a> {
            Builder { builder: builder }
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Builder<'a> {
            ::capnp::traits::FromStructBuilder::new(builder.init_struct(_private::STRUCT_SIZE))
        }
        fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>) -> Result<Builder<'a>> {
            ::std::result::Result::Ok(::capnp::traits::FromStructBuilder::new(try!(builder.get_struct(_private::STRUCT_SIZE, ::std::ptr::null()))))
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder<Builder<'a>> for Reader<'a> {
        fn set_pointer_builder<'b>(pointer: ::capnp::private::layout::PointerBuilder<'b>, value: Reader<'a>) -> Result<()> {
            pointer.set_struct(&value.reader)
        }
    }

    impl<'a> Builder<'a> {
        pub fn as_reader(self) -> Reader<'a> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }
        pub fn borrow<'b>(&'b mut self) -> Builder<'b> {
            Builder { ..*self }
        }
        pub fn borrow_as_reader<'b>(&'b self) -> Reader<'b> {
            ::capnp::traits::FromStructReader::new(self.builder.as_reader())
        }

        pub fn total_size(&self) -> Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn set_success(&mut self, value: data::Reader) {
            self.builder.set_data_field::<u16>(0, 0);
            self.builder.get_pointer_field(0).set_data(value);
        }
        #[inline]
        pub fn init_success(self, size: u32) -> data::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 0);
            self.builder.get_pointer_field(0).init_data(size)
        }
        pub fn has_success(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 0 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn set_unknown_leader(&mut self, _value: ()) {
            self.builder.set_data_field::<u16>(0, 1);
        }
        #[inline]
        pub fn set_not_leader(&mut self, value: text::Reader) {
            self.builder.set_data_field::<u16>(0, 2);
            self.builder.get_pointer_field(0).set_text(value);
        }
        #[inline]
        pub fn init_not_leader(self, size: u32) -> text::Builder<'a> {
            self.builder.set_data_field::<u16>(0, 2);
            self.builder.get_pointer_field(0).init_text(size)
        }
        pub fn has_not_leader(&self) -> bool {
            if self.builder.get_data_field::<u16>(0) != 2 {
                return false;
            }
            !self.builder.get_pointer_field(0).is_null()
        }
        #[inline]
        pub fn which(self) -> ::std::result::Result<WhichBuilder<'a>, ::capnp::NotInSchema> {
            match self.builder.get_data_field::<u16>(0) {
                0 => {
                    return ::std::result::Result::Ok(Success(self.builder.get_pointer_field(0).get_data(::std::ptr::null(), 0)));
                }
                1 => {
                    return ::std::result::Result::Ok(UnknownLeader(()));
                }
                2 => {
                    return ::std::result::Result::Ok(NotLeader(self.builder.get_pointer_field(0).get_text(::std::ptr::null(), 0)));
                }
                x => return ::std::result::Result::Err(::capnp::NotInSchema(x)),
            }
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Pipeline {
            Pipeline { _typeless: typeless }
        }
    }
    impl Pipeline {}
    mod _private {
        use capnp::private::layout;
        pub const STRUCT_SIZE: layout::StructSize = layout::StructSize { data: 1, pointers: 1 };
        pub const TYPE_ID: u64 = 0xb44a106f8a977a75;
    }
    pub enum Which<A0, A1> {
        Success(A0),
        UnknownLeader(()),
        NotLeader(A1),
    }
    pub type WhichReader<'a> = Which<Result<data::Reader<'a>>, Result<text::Reader<'a>>>;
    pub type WhichBuilder<'a> = Which<Result<data::Builder<'a>>, Result<text::Builder<'a>>>;
}
